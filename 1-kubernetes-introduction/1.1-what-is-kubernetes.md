# 1.1 Kubernetes 是什么

## Kubernetes是什么？

首先，它是一个全新的基于容器技术的分布式架构领先方案。这个方案虽然还很新，但它是谷歌十几年以来大规模应用容器技术的经验积累和升华的重要成果。确切地说 Kubernetes 是谷歌严格保密十几年的秘密武器 --- Borg 的一个开源版本。Borg 是谷歌的一个久负盛名的内部使用的大规模集群管理系统，它基于容器技术，目的是实现资源管理的自动化，以及跨多个数据中心的资源利用率的最大化。十几年以来，谷歌一直通过 Borg 系统管理着数量庞大的应用程序集群。由于谷歌员工都签署了保密协议，即使离职也不能泄露 Borg 的内部设计，所以外界一直无法了解关于它的更多信息。直到 2015 年 4 月，传闻许久的 Borg 论文伴随 Kubernetes 的高调宣传谷歌首次公开，大家才得以了解它的更多内幕。正是由于站在 Borg 这个前辈的肩膀上，汲取了 Borg 过去十年间的经验与教训，所以 Kubernetes 一经开源就一鸣惊人，并迅速称霸容器领域。

其次，如果我们的系统设计遵循了 Kubernetes 的设计思想，那么传统系统架构中那些和业务没有多大关系的底层代码或功能模块，都可以立即从我们的视线中消失，我们不必再费心于负载均衡器的选型和部署实施问题，不必再考虑引入或自己开发一个复杂的服务解决方案，我们不仅节省了不少于 30% 的开发成本，还可以将精力更加集中于业务本身，而且由于 Kubernetes 提供了强大的自动化机制，所以系统后期的运维难度和运维成本大幅度降低。

然后，Kubernetes 是一个开放的开发平台。与 J2EE 不同，它不局限于任何一种语言，没有限定任何编程接口，所以不论是用 Java、Go、C++ 还是用 Python 编写的服务，都可以被映射为 Kubernetes 的 Service（服务），并通过标准的 TCP 通信协议进行交互。此外，Kubernetes 平台对现有的编程语言、编程框架、中间件没有任何侵入性，因此现有的系统也很容易改造升级并迁移到 Kubernetes 平台上。

最后，Kubernetes 是一个完备的分布式系统支撑平台。Kubernetes 具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租房应用支撑能力、透明的服务注册和服务发现机制、内建的智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。同时，Kubernetes 提供了完善的管理工具，这些工具涵盖了包括开发、部署测试、运维监控在内的各个环节。因此，Kubernetes 是一个全新的基于容器技术的分布式架构解决方案，并且是一个一站式的完备的分布式系统开发和支撑平台。

在正式开始本章的 "Hello World" 之旅之前，我们首先要学习 Kubernetes 的一些基本知识，这样才能理解 Kubernetes 提供的解决方案。

## 特征

在 Kubernetes 中，Service 是分布式集群架构的核心，一个 Service 对象拥有如下关键特征：

* 拥有唯一指定的名称。
* 拥有一个虚拟IP（Cluster IP、Service IP或VIP）和端口号。
* 能够提供某种远程服务能力。
* 被映射到提供这种服务能力的一组容器应用上。

## Service

Service 的服务进程目前都基于 Socket 通信方式对外提供服务，比如 Redis、Memcached、MySQL、WebServer，或者是实现了某个具体业务的特定 TCP Server 进程。虽然一个 Service 通常由多个相关的服务进程提供服务，每个服务进程都有一个独立的 Endpoint（IP + Port）访问点，但 Kubernetes 能够让我们通过 Service（虚拟 Cluster IP + Service Port）连接到指定的 Service。有了 Kubernetes 内建的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否由于发生故障而被重新部署到其他机器，都不会影响对服务的正常调用。更重要的是，这个 Service 本身一旦创建就不再变化，这意味着我们再也不用为 Kubernetes 集群中服务的 IP 地址变来变去的问题而头疼了。

## Pod

容器提供了强大的隔离功能，所以有必要把为 Service 提供服务的这组进程放入容器中进行隔离。为此，Kubernetes 设计了`Pod`对象，将每个服务进程都包装到相应的 Pod 中使其成为在Pod中运行的一个容器（`Container`）。为了建立 Service 和 Pod 间的关联关系，Kubernetes 首先给每个 Pod 都贴上一个标签（`Label`），给运行 MySQL 的 Pod 贴上 name=mysql 标签，给运行 PHP 的 Pod 贴上 name=php 标签，然后给相应的 Service 定义标签选择器（`Label Selector`），比如 MySQL Service 的标签选择器的选择条件为 name=mysql，意为该 Service 要作用于所有包含 name=mysql Label 的 Pod。这样一来，就巧妙解决了 Service 与 Pod 的关联问题。

这里先简单介绍 Pod 的概念。首先，Pod 运行在一个被称为节点（`Node`）的环境中，这个节点既可以是物理机，也可以是私有云或者公有云的一个虚拟机，通常一个节点上运行几百个 Pod；其次，在每个 Pod 中都运行着一个特殊的被称为`Pause`的容器，其他容器则为业务容器，这些业务容器共享 Pause 容器的网络栈和 Volume 挂载卷，因此它们之间的通信和数据交换更为高效，在设计时我们可以充分利用这一特性将一组密切相关的服务进程放入同一个 Pod 中；最后，需要注意的是，并不是每个 Pod 和它里面运行的容器都能被映射到一个 Service 上，只有提供服务（无论是对内还是对外）的那组 Pod 才会被映射为一个服务。

## 集群管理

在集群管理方面，Kubernetes 将集群中的机器划分为一个 Master 和一些 Node。在 Master 上运行着集群管理相关的一组进程 `kube-apiserver`、`kube-controller-manager`和`kube-scheduler`，这些进程实现了整个集群的资源管理、Pod 调试、弹性伸缩、安全控制、系统监控和纠错等管理功能，并且都是自动完成的。Node 作为集群中的工作节点，运行真正的应用程序，在 Node 上 Kubernetes 管理的最小运行单元是 Pod。在 Node 上运行着 Kubernetes 的`kubelet`、`kube-proxy`服务进程，这些服务进程负责 Pod 的创建、启动、监控、重启、销毁，以及实现软件模式的负载均衡器。

最后，看看传统和IT系统中服务扩容和服务升级这两个难题，以及 Kubernetes 所提供的全新解决思路。服务的扩容涉及资源分配（选择哪个节点进行扩容）、实例部署和启动等环节，在一个复杂的业务系统中，这两个难题基本上靠人工一步步操作才得以解决，费时费力又难以保证实施质量。

在 Kubernetes 集群中，只需为需要扩容的 Service 关联的 Pod 创建一个 RC（`Replication Controller`），服务扩容以至服务升级等令人头疼的问题都迎刃而解。在一个RC定义文件中包括以下3个关键信息：

* 目标 Pod 的定义。
* 目标 Pod 需要运行的副本数量（`Replicas`）。
* 要监控的目标 Pod 的标签。

在创建好 RC（系统将自动创建Pod）后，Kubernetes 会通过 RC 中定义的 Label 筛选出对应的Pod实例并实时监控其状态和数量，如果实例数量少于定义的副本数量，则会根据在RC中定义的 Pod 模板创建一个新的 Pod，然后将此 Pod 调度到合适的Node上自动运行，直到 Pod 实例的数量达到预定目标。这个过程完全是自动化的，无须人工干预。有了 RC，服务扩容就变成一个纯粹的简单数字游戏了，只需修改 RC 中的副本数量既可。后续的服务升级也将通过修改 RC 来自动完成。

## ...

以将在第2章中介绍的 PHP + Redis 留言板应用为例，只要为 PHP 留言板程序（frontend）创建一个有3个副本的 RC+Service，为 Redis 读写分离集群创建两个 RC：写节点（redis-master）创建一个单副本的 RC+Service，读节点（redis-slaver）创建一个有两个副本的 RC+Service，就可以快速完成整个集群的搭建过程，是不是很简单？

